<!doctype html>
<html lang="en">

<!--
Copyright (C) 2020-2021 OpenBikeSensor Contributors
Contact: https://openbikesensor.org

This file is part of the OpenBikeSensor Scripts Collection.

The OpenBikeSensor Scripts Collection is free software: you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3 of the License,
or (at your option) any later version.

The OpenBikeSensor Scripts Collection is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the OpenBikeSensor Scripts Collection.  If not, see
<http://www.gnu.org/licenses/>.
-->

<head>
	<meta charset="utf-8">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css" type="text/css">
	<style>
		.map {
			position: absolute;
			width: 100%;
			height: 100%;
			left: 0px;
			top: 0px;
			z-index: 0;
		}

		.bw {
		    filter: grayscale(100%) opacity(50%);
		}

		.overlay {
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			position: absolute;
			width: 30%;
			height: 98%;
			left: 1%;
			top: 1%;
			z-index: 0;
			pointer-events: none;
		}

		.title {
			display: flex;
			position: relative;
			height: 10%;
			width: 100%;
#			background-color: #FFFFFF;
			padding: 5px;
			z-index: 0;
		}

		.title_image {
			height: 100%
		}

		.title_text {
			padding: 0px;
			height: 100%;
			vertical-align: middle;
			background-color: #FF8080;
		}

		.caption {
			display: flex;
			height: 20%;
			width: 100%;
			background-color: #FFFFFF;
			padding: 5px;
			align-items: center;
			z-index: 0;
			pointer-events: auto;
		}

		.chart {
			width: 100%;
			height: 30%;
			background-color: #FFFFFF;
			padding: 5px;
			z-index: 0;
			pointer-events: auto;
		}

		.ol-zoom {
			left: unset;
			right: 8px;
		}
		td {
			padding-left: 10px;
		}
	</style>
	<script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
	<script src="OBS.js"></script>
	<title>OpenBikeSensor Visualisierung: Stra&szlig;enabschnitte</title>
</head>

<body>
	<div id="map" class="map"></div>
	<div id="overlay" class="overlay">
		<div id="chart" class="chart"></div>
		<div id="title" class="title">
			<div id="title_image"><img src="images/OBS.png" height="100%"></img></div>
		</div>
		<div id="caption" class="caption">
		</div>
	</div>

	<script type="text/javascript">
		//			var criterion = "d_mean";
		// var criterion = "p_above";
		var criterion = "d_quartile";

		var hist_xa = 0.0;
		var hist_xb = 2.55;
		var hist_xb_extends_to_infinity = true;
		var hist_dx = 0.25;
		var hist_n = Math.ceil((hist_xb - hist_xa) / hist_dx);
		var selectedFeatures = [];
		var globalStats;

		function histogramLabels() {

			var labels = Array(hist_n);
			for (var i = 0; i < hist_n; i++) {
				var xa = hist_xa + hist_dx * i;
				var xb = xa + hist_dx;
				var xc = xa + 0.5 * hist_dx;
				if (hist_xb_extends_to_infinity &&  (i == hist_n - 1)){
					labels[i] = "≥" + (xa * 100).toFixed(0)
				} else {
					labels[i] = (xa * 100).toFixed(0) + "-" + (xb * 100).toFixed(0);
				}
			}

			return labels;
		}

		function histogramColors(palette) {

			var colors = Array(hist_n);
			for (var i = 0; i < hist_n; i++) {
				var xc = hist_xa + hist_dx * i;
				colors[i] = palette.rgb_hex(xc);
			}

			return colors;
		}

		function histogram(samples) {
			var binCounts = new Array(hist_n).fill(0);

			for (var i = 0; i < samples.length; i++) {
				var v = samples[i];
				var j = Math.floor((v - hist_xa) / hist_dx);
				if (hist_xb_extends_to_infinity){
					j = Math.min(j, hist_n - 1);
				}
				if (j >= 0 && j < hist_n) {
					binCounts[j]++;
				}
			}

			return binCounts;
		}
		function getMeasurements(features) {
			var m = [];
			features.forEach(feature => {
				m = m.concat(feature.get('distance_overtaker_measurements'));
			});
			m.sort((a, b) => a - b);
			return m;
		}
		function getStats(features) {
			var limit = 100;
			var m = getMeasurements(features);
			var ticks = 0;
			features.forEach(feature => {
				var l = feature.get('distance_overtaker_limit');
				if (l < limit) limit = l;
				ticks += feature.get('ticks');
			});
			stats = {};
			stats.n = m.length;
			stats.median = m.length > 0 ? m[Math.floor(m.length/2)] : 0;
			stats.min = m.length > 0 ? m[0] : 0;
			stats.below = 0;
			stats.limit = limit;
			stats.ticks = ticks;
			stats.m = m;
			for (let i = 0; i < m.length && m[i] < limit; i++) stats.below++;
			return stats;
		}

		function annotation(features) {
			var stats = globalStats;
			var way_id = 'all';
			var name;
			if (features.length > 0) {
				 stats = getStats(features);
				var feature = features[0];
				way_id = feature.get('way_id');
				name = feature.get('name');
			}
			var s = "<table>";
			if (name) {
				s += "<tr><td>Stra&szlig;enname:</td><td colspan='3'><a href=\"https://www.openstreetmap.org/way/" + way_id + "\" target=\"_blank\">" + name + "</a></td></tr>";
			}
			else {
				s += "<tr><td colspan='5'><b>&Uuml;bersicht</b>. <br/>Bitte Stra&szlig;en anklicken um lokale Informationen zu erhalten. Einzelne Segmente k&ouml;nnen mit 'Shift' an- und abgew&auml;hlt werden.</td></tr>";
			}
			s += "<tr height=\"5em\"></tr>";


			var ticks = stats.ticks;
			if (ticks == 0) ticks = 1;
			var m = stats.m;
			var mean = 0;
			for (let i = 0; i < m.length; i++) {
				mean += m[i];
			}
			s += "<tr><td></td><td>Mittel</td><td>Viertel</td><td>Zehntel</td><td>Minimum</td></tr>";
			s += "<tr><td>&Uuml;berholabst&auml;nde:</td><td>";
			s += ((stats.median == 0) ? "n/a" : stats.median.toFixed(2)) + " m </td><td>";

			var quartil = (m.length > 0) ? m[Math.floor(m.length/4)] : 0;
			s += ((quartil == 0) ? "n/a" : quartil.toFixed(2)) + " m </td><td>";

			var dezil = (m.length > 0) ? m[Math.floor(m.length/10)] : 0;
			s += ((dezil == 0) ? "n/a" : dezil.toFixed(2)) + " m </td><td>";
			s += ((m.length == 0) ? "n/a" : m[0].toFixed(2)) + " m </td></tr>";


			s += "<tr height=\"5em\"></tr>";

			var p = stats.below / stats.n * 100.0;
			s += "<tr><td>Unterschreitung Mindestabstand von " + ((stats.limit == null) ? "n/a" : stats.limit.toFixed(2)) + " m :</td><td colspan='3'>" + ((stats.n == 0) ? "n/a" : p.toFixed(1)) + "% der &Uuml;berholenden</td></tr>";

			s += "<tr><td>&Uuml;berholvorg&auml;nge pro Minute:</td><td>" + (m.length / ticks * 60).toFixed(1) + "</td></tr>";

			s += "<tr><td>Anzahl &Uuml;berholvorg&auml;nge:</td><td>" + stats.n.toFixed(0) + "</td></tr>";

			if (ticks > 3600) {
				s += "<tr><td>Dauer der Erfassung:</td><td>" + (ticks / 3600).toFixed(1) + " h</td></tr>";
			}
			else {
				s += "<tr><td>Dauer der Erfassung:</td><td colspan='2'>" + (ticks / 60).toFixed(1) + " min</td></tr>";
			}

			s += "</table>";

			return s;
		}

		function smoothStep(x, a, b) {
			var y = (x - a) / (b - a);
			return Math.max(0.0, Math.min(1.0, y));
		}

		function styleFunction(feature, resolution, active = false) {
			var m = feature.get('distance_overtaker_measurements');
			var zone = feature.get('zone');
			if (zone == "urban") {
				palette = paletteUrban;
			} else if (zone == "rural") {
				palette = paletteRural;
			} else {
				palette = paletteUrban;
			}

			var valid = feature.get('valid');

			var color = [0, 0, 0, 255];

			if (valid) {
				var rgba;
				switch (criterion) {
					case "d_median":
						color = palette.rgba(m[Math.floor(m.length/2)])
						break;
					case "d_quartile":
						color = palette.rgba(m[Math.floor(m.length/4)])
						break;
					case "d_min":
						color = palette.rgba(m[0])
						break;
				}
				if (m.length < 2) {
					var sum = color[0] + color[1] + color[2];
					color = [color[0] * 240 / sum, color[1] * 240 / sum, color[2] * 240 / sum, 255];
					if (color[0] < 220) color[0] = 220;
					if (color[1] < 220) color[1] = 220;
					if (color[2] < 220) color[2] = 220;
				}
			} else {
				color = [220, 230, 220, 255];
			}

			var width = (active ? 4.0 : 2.0); // * detail + 4 * mid + 200.0 / resolution * overview;

			var style = new ol.style.Style({
				stroke: new ol.style.Stroke({
					color: color,
					width: width,
				})
			});
			return style;
		}

		var map = new ol.Map({
			target: 'map',
			interactions : ol.interaction.defaults({doubleClickZoom :false}),
			layers: [
				new ol.layer.Tile({
				    className: "bw",
					source: new ol.source.OSM({
						crossOrigin: null,
						url: 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'
					})
				})
			],
			view: new ol.View({
				center: ol.proj.fromLonLat([9.1798000, 48.7759000]),
	  			zoom: 13
			})
		});



		var dataSource = new ol.source.Vector({
			format: new ol.format.GeoJSON(),
			url: 'json/roads.json'
		})

		var vectorLayer = new ol.layer.Vector({
			source: dataSource,
			style: styleFunction
		});

		map.addLayer(vectorLayer);

		const changeListener = dataSource.once('change', function(event) {
    		if (dataSource.getState() == 'ready') {
				const extent = vectorLayer.getSource().getExtent();
				const mapSize = map.getSize();
				const overlay = document.getElementById("overlay");
				const marginLeft = overlay.offsetWidth + overlay.offsetLeft;
    			map.getView().fit(extent, {size: mapSize, padding: [0, 0, 0, marginLeft]});
				var evt0 = {coordinate: [0,0]};
				onclick(evt0);

			}
		});

		var histogramColorsRural = histogramColors(paletteRural).reverse();
		var histogramColorsUrban = histogramColors(paletteUrban).reverse();

		var chartOptions = {
			series: [{
				name: 'Überholende',
				data: Array(hist_n).fill(0)
			}],
			chart: {
				type: 'bar',
				height: 350,
				animations: {
					animateGradually: {
						enabled: false
					}
				}
			},
			plotOptions: {
				bar: {
					horizontal: false,
					columnWidth: '95%',
					endingShape: 'flat',
					distributed: true
				},
			},
			dataLabels: {
				enabled: true
			},
			stroke: {
				show: false,
			},
			xaxis: {
				title: {
					text: 'Überholabstand in Zentimeter'
				},
				categories: histogramLabels().reverse(),
			},
			yaxis: {
				title: {
					text: 'Anzahl Überholende'
				},
				labels: {
					show: false
				}
			},
			fill: {
				opacity: 1,
			},
			legend: {
				show: false
			},
			tooltip: {
				y: {
					formatter: function (val) {
						return val
					}
				}
			}
		};

		var chart = new ApexCharts(document.querySelector("#chart"), chartOptions);
		chart.render();

		function onclick(evt) {
			var lonlat = ol.proj.transform(evt.coordinate, 'EPSG:3857', 'EPSG:4326');
			var feature = vectorLayer.getSource().getClosestFeatureToCoordinate(evt.coordinate);
			var distance = 10000;
			if (feature) {
				var closest = feature.getGeometry().getClosestPoint(evt.coordinate);
				var lonlat2 = ol.proj.transform(closest, 'EPSG:3857', 'EPSG:4326');
				distance = ol.sphere.getDistance([lonlat[0], lonlat[1]], [lonlat2[0], lonlat2[1]]);
			}
			var resolution = map.getView().getResolution();

			var colors = histogramColorsUrban;
			if (feature && feature.get('zone') == "rural") {
				colors = histogramColorsRural;
			}
			chart.updateOptions({
				colors: colors
			});
			var hist;
			var total = [];
			if (distance > 100) {
				vectorLayer.getSource().getFeatures().forEach(f => { total.push(f); });
				selectedFeatures.forEach(f => {
					f.setStyle(styleFunction(f, resolution, false));
				});
				hist = histogram(total).reverse();
				if (globalStats == undefined) {
					globalStats = getStats(total);
				}
				selectedFeatures = [];
			}
			else if (feature && !evt.originalEvent.shiftKey) {
				selectedFeatures.forEach(f => {
					f.setStyle(styleFunction(f, resolution, false));
				});
				var name = feature.values_.name;
				var total = [];
				selectedFeatures = [];
				vectorLayer.getSource().getFeatures().forEach(f => {
					if (f.values_.name == name) {
						f.setStyle(styleFunction(f, resolution, true));
						selectedFeatures.push(f);
					}
				});
			}
			else if (feature && dataSource.hasFeature(feature)) {

				if (selectedFeatures.includes(feature)) {
					selectedFeatures.splice(selectedFeatures.indexOf(feature), 1);
					feature.setStyle(styleFunction(feature, resolution, false));
				}
				else {
					feature.setStyle(styleFunction(feature, resolution, true));
					selectedFeatures.push(feature);
				}
			}
			caption.innerHTML = annotation(selectedFeatures);
			caption.style.alignItems = "flex-start";

			if (selectedFeatures.length > 0) total = selectedFeatures;
			hist = histogram(getMeasurements(total)).reverse();

			chart.updateSeries([{
				name: 'Überholende',
				data: hist,
			}]);

			noFeatureActive = false;

		}
		map.on('singleclick', onclick);

	</script>
</body>

</html>
